<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="How to integrate with IdentityX UAF Server">
    <meta name="author" content="Daon">
    <title>IdentityX FIDO Integration Documentation</title>
    <script src='lib/jquery.js' type='text/javascript'></script>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <!-- highlight - view JSON all nice -->
    <link href="styles/github.css" rel="stylesheet">
    <script src='lib/highlight.js' type='text/javascript'></script>
    <!-- initialize the highlighter -->
    <!-- Custom CSS -->
    <link href="css/simple-sidebar.css" rel="stylesheet">
    <link href="css/index.css" rel="stylesheet" />
    <link href='css/standalone.css' rel='stylesheet' />
    <link href='css/api-explorer.css' rel='stylesheet' type='text/css' />
    <link href='css/doco.css' rel='stylesheet' type='text/css' />
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="shortcut icon" href="images/favicon.ico" />
</head>

<body>
    <script>
    hljs.initHighlightingOnLoad();
    </script>
    <div id="wrapper">
        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                </li>
                <li>
                    <a href="#overview">1. Overview</a>
                </li>
                <li>
                    <a href="#adminConsole">2. Admin Console</a>
                </li>
                <li>
                    <a href="#programmingIdentityX">3. Programming IdentityX</a>
                </li>
                <li>
                    <a href="#creatingEntities">4. Creating Entities</a>
                </li>
                <li>
                    <a href="#registration">5. Registration</a>
                </li>
                <li>
                    <a href="#authentication">6. Authentication</a>
                </li>
                <li>
                    <a href="#deregistration">7. De-registration</a>
                </li>
                <li>
                    <a href="#transactionConfirmation">8. Transaction Confirmation</a>
                </li>
                <li>
                    <a href="#sampleApplication">9. Sample Application</a>
                </li>
                <li>
                    <a href="#commonErrors">10. Common Errors</a>
                </li>
                <li>
                    <a href="#otherFIDOServers" class="lastItem">11. Other FIDO Servers</a>
                </li>
            </ul>
        </div>
        <!-- /#sidebar-wrapper -->
        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid docs-content">
                <!-- OVERVIEW -->
                <a name="overview"></a>
                <div class="row">
                    <div class="col-lg-12">
                        <h1>1. Overview</h1>
                        <h2>1.1 Introduction</h2>
                        <p>The purpose of this document is to describe how to integrate with the IdentityX Server to enable FIDO authentication options to a Relying Party Server Application (RPSA).</p>
                        <p>Figure 1 - FIDO Solution with IdentityX shows the high level architecture of a Relying Party Server Application (RPSA) using IdentityX to support FIDO authentication.</p>
                        <center>
                            <a href="#figure1" class="openModal">
                                <img class="imageresource" src="images/large/FIDO_Solution_with_IdentityX.png" style="width: 70%;">
                                <br />
                                <figcaption>Figure 1 - FIDO Solution with IdentityX (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>The diagram shows two possible options for using FIDO on the device (PC, tablet or smartphone):</p>
                        <ol>
                            <li><strong>Platform Specific App:</strong> A FIDO enabled Relying Party App (RPApp) runs on the user’s device and that app communicates across the network with the Relying Party Server (RPSA) and that app also communicates with the FIDO client through the published platform specific FIDO inter-process communications protocols.</li>
                            <li><strong>Web Application: </strong> The web pages from the FIDO enabled Web App run within a FIDO enabled browser on the user’s device. The browser communicates across the network with the Relying Party Server Application (RPSA) and the Web App communicates with the browser’s FIDO client through the published DOM interface. Unfortunately at this time (October 2015), there are no publicly available web browsers which support the FIDO UAF DOM interface.</li>
                        </ol>
                        <p>While these are the two most commonly expected options for the use of FIDO on a device, other options are possible, for example, where the Relying Party App includes the FIDO Client and Authenticator or where the Relying Party App includes just the FIDO Authenticator. </p>
                        <p>This document focuses on the communication between the Relying Party Server and the IdentityX server for the purposes of:</p>
                        <ol>
                            <li>Registration – enabling users to use FIDO for authentication</li>
                            <li>Authentication – authenticating users with FIDO</li>
                            <li>Transaction Confirmation – using FIDO to confirm transactions with users</li>
                            <li>Deregistration – removing FIDO authentication capability from users</li>
                        </ol>
                        </p>
                        <h2>1.2 IdentityX Class Model</h2>
                        <p>Figure 2 - IdentityX Class Model shows the core classes (or entities) within IdentityX and the relationships between them with UML class notation.</p>
                        <center>
                            <a href="#figure2" class="openModal">
                                <img id="imageresource" src="images/large/IdentityX_Class_Model.png" style="width: 70%;">
                                <br />
                                <figcaption>Figure 2 - IdentityX Class Model (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>It is important to understand the purpose of the entities and the relationships between the entities as integrating a Relying Party Server Application (RPSA) with IdentityX requires the creation and use of these entities.</p>
                        <p>In order for a user to authenticate with FIDO the following items must be in place:</p>
                        <ol>
                            <li>An <strong>Application</strong> entity corresponding to the Relying Party Server Application. IdentityX supports more than one application thus enabling multiple external Relying Party Server Applications all connecting to the same IdentityX system.</li>
                            <li>At least one <strong>Authenticator Type</strong> entity corresponding to a class of FIDO authenticator. From the FIDO specification:
                                <p><i>“A FIDO Authenticator is responsible for user verification, and maintaining the cryptographic material required for the relying party authentication."</i></p>
                                Each FIDO Authenticator has an Authenticator Attestation ID (AAID) which uniquely identifies the “class" or “type" of authenticator. In IdentityX, the Authenticator Type is the entity which holds all the information related to the AAID. Only FIDO Authenticators with types known to IdentityX can be used by IdentityX.
                            </li>
                            <li>A <strong>Registration Policy</strong> entity specifying the acceptable (and unacceptable) Authenticator Types which may be registered by a user.</li>
                            <li>An <strong>Authentication Policy</strong> entity specifying the acceptable (and unacceptable) Authenticator Types which may be used to satisfy an authentication by a user.</li>
                            <li>A <strong>User</strong> entity corresponding to each user to be authenticated.</li>
                            <li>A <strong>Registration</strong> entity identifying the relationship between each User and the Application.</li>
                            <li>A <strong>Registration Challenge</strong> entity which facilitates the association of an Authenticator (or Authenticators) and the User.</li>
                            <li>An <strong>Authenticator</strong> entity which represents the FIDO authenticator the user has registered to use with the Application.</li>
                            <li>An <strong>Authentication Request</strong> entity which facilities the actual authentication associated with a specific Authentication Policy.</li>
                        </ol>
                        <p>The <strong>Application</strong>, <strong>Authenticator Type</strong>, <strong>Registration Policy</strong> and <strong>Authentication Policy</strong> entities may all be created through the IdentityX Admin Console. Section 2 of this document describes how these items are created.</p>
                        <p>The <strong>User</strong>, <strong>Registration</strong>, <strong>Registration Challenge</strong> and <strong>Authentication Request</strong> must be created programmatically by the Relying Party Server Application. Sections 4, 5 and 6 of this document describes how these items are created.</p>
                        <h2>1.3 FIDO Authenticators, Authenticator Types and Authenticators</h2>
                        <p>The distinction between FIDO Authenticators (as defined by the FIDO Specification), Authenticator Types and Authenticators may not be initially clear. The FIDO Specification does not draw a distinction between the class of an Authenticator and instances of that Authenticator.</p>
                        <ul style="list-style-type:circle">
                            <li><strong>Authenticator Type:</strong> In IdentityX, Authenticator Type refers to the class of an Authenticator e.g. the Samsung Galaxy S6 fingerprint authenticator is a <em>class</em> of FIDO Authenticator. An Authenticator Type, like a FIDO Authenticator is defined by its AAID and associated Meta-data.</li>
                            <li><strong>Authenticator:</strong> In IdentityX, Authenticator refers to an instance of an Authenticator Type for example, the fingerprint authenticator on Tom’s Samsung Galaxy S6 phone is an Authenticator in IdentityX. Every Authenticator in IdentityX has an associated Authenticator Type.</li>
                        </ul>
                    </div>
                </div>
                <!-- OVERVIEW END -->
                <!-- ADMIN CONSOLE -->
                <a name="adminConsole"></a>
                <div class="row">
                    <div class="col-lg-12">
                        <h1>2. Admin Console</h1>
                        <h2>2.1 Understanding FIDO Concepts</h2>
                        <p>In order to understand how to create an Application within IdentityX, it is important to understand the FIDO concepts of Facets and AppIDs.</p>
                        <h3>2.1.1 Facets</h3>
                        <p>An application facet is the method of identifying an application in a platform specific manner to the FIDO client. Facets are important within FIDO as they are used by the FIDO clients to ensure that only authorized, authenticated applications (or apps) may request access to the private keys managed by the FIDO clients/authenticators.</p>
                        <p>The following is the definition from the FIDO specification:</p>
                        <p><i>“An (application) facet is how an application is implemented on various platforms.  For example, the application MyBank may have an Android app, an iOS app, and a Web app. These are all facets of the MyBank application."</i></p>
                        <h3>2.1.2 AppID</h3>
                        <p>The AppID defines the Relying Party Server Application and determines the applications (or apps) which may request access to the private key on the user’s authenticator.</p>
                        <p>The following is the definition from the FIDO specification:</p>
                        <p><i>“The AppID is an identifier for a set of different Facets of a relying party's application. The AppID is a URL pointing to the TrustedFacets, that is, list of FacetIDs related to this AppID." </i></p>
                        <p>An example of an AppID would be</p>
                        <p><pre><code>https://fido.companyA.hosting.example.com/SampleApplication/facets</code></pre></p>
                        <p>At this location, must be hosted a JSON document containing an array of facets as follows:</p>
                        <p><pre><code class="json hljs">
{
  "trustedFacets" : [{
    "version": { "major": 1, "minor" : 0 },
    "ids": [
      "https://fido.companyA.hosting.example.com",
      "https://xyz.companyA.hosting.example.com",
      "android:apk-key-hash:dS6oorhfXCyrmiVFrh3lRr4HYKg"
    ]
  }]
}
                        </code></pre></p>
                        <p>AppID must be a secure TLS location (https) and production FIDO clients will not accept non TLS locations. In addition the FIDO specification requires that the <strong>Content-Type</strong> associated with the Facet document should be: <strong>“application/fido.trusted-apps+json”</strong>.</p>
                        <a name="creatingAnApplication"></a>
                        <h2>2.2 Creating an Application in IdentityX</h2>
                        <p>To create a FIDO Application and manage the FIDO Facet IDs, logon to the IdentityX Admin Console. Navigate to the “Applications” and select “Create Application”:</p>
                        <center>
                            <a href="#figure3" class="openModal">
                                <img id="imageresource" src="images/large/Create_Application_Form.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 3: Create Application Form (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Enter the following items:</p>
                        <ul style="list-style-type:circle">
                            <li><strong>Application ID</strong> – a unique identifier for the Application</li>
                            <li><strong>FIDO Application ID</strong> – the URL required to access the list of Facets. The FIDO Specification refers to this as the AppID.</li>
                        </ul>
                        <p>You may enter the other fields, but only these two are required to create an Application.</p>
                        <p>Note the <em>“Application ID”</em> of the Application.</p>
                        <p>Next navigate to the “Facets” Tab which is on the left of the details view of the Application as shown in Figure 4 - Selecting Facets.</p>
                        <center>
                            <a href="#figure4" class="openModal">
                                <img id="imageresource" src="images/large/Selecting_Facets.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 4: Selecting Facets (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Once “Facets” is selected, click “Create Facet” to create a new Facet. The dialog as shown in Figure 5 - Creating a Facet will display.</p>
                        <center>
                            <a href="#figure5" class="openModal">
                                <img id="imageresource" src="images/large/Creating_a_Facet.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 5: Creating a Facet (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>There is currently only a single published version of the FIDO UAF Specification (v1.0) and as such the version number cannot be changed at this point.</p>
                        <p>The Facet ID should be entered directly into the “Facet ID” text box. The entries should be of the following format:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 80%;">
                                <thead>
                                    <tr>
                                        <th style="width: 20%;">Source</th>
                                        <th style="width: 30%;">Format</th>
                                        <th>Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td id="href">Web</td>
                                        <td>URL with TLS</td>
                                        <td>https://fido.companyA.hosting.example.com</td>
                                    </tr>
                                    <tr>
                                        <td id="href">Android</td>
                                        <td><em>“android:apk-key-hash:”</em> followed by the SHA1 hash of the certificate used to sign the APK.</td>
                                        <td>android:apk-key-hash:dS6oorhfXCyrmiVFrh3lRr4HYKg</td>
                                    </tr>
                                    <tr>
                                        <td id="href">iOS</td>
                                        <td><em>“ios:bundle-id:”</em> followed by the iOS bundle ID.</td>
                                        <td>ios:bundle-id:
                                            <ios-bundle-id-of-app>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>NOTE 1:</strong> There may be zero or more entries for each source allowing multiple web sites, Android or iOS apps to be associated with the same application (AppID).</p>
                        <p><strong>NOTE 2:</strong> If the facets are updated while the FIDO Relying Party Server Application is running, then the FIDO Relying Party Server Application must be restarted as the facets are cached by the Relying Party Server Application.</p>
                        <h2>2.3 Creating an Authenticator Type</h2>
                        <p>IdentityX maintains a list of Authenticator Types and this list must be kept current as IdentityX will only allow the use of FIDO authenticators of which it is aware. To add (or manage) a FIDO Authenticator Type, logon to the IdentityX Admin Console and navigate to “Administration / Authenticator Types”.</p>
                        <p>Here there are two options to “Create” or “Import”. It is worth selecting the “Import” button to see if the instance of IdentityX has the required Authenticator Type. If it is in the list of Authenticator Types, simply click import on the required type.</p>
                        <center>
                            <a href="#figure6" class="openModal">
                                <img id="imageresource" src="images/large/Importing_an_Authenticator_Type.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 6: Importing an Authenticator Type (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Creating a new Authenticator Type from scratch requires access to the Authenticator Type meta-data in JSON format (as published by the FIDO Alliance). To create a new Authenticator, simply click “Create”.</p>
                        <center>
                            <a href="#figure7" class="openModal">
                                <img id="imageresource" src="images/large/Create_a_new_Authenticator_Type.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 7: Create a new Authenticator Type (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Enter the name to be given to the Authenticator Type and the vendor name and then click “Browse” to select the JSON file with the meta-data for the Authenticator Type.</p>
                        <p>Once these have been selected, click “Create” to add the Authenticator Type to IdentityX.</p>
                        <h2>2.4 Creating the Registration Policy</h2>
                        <p>A registration policy determines which Authenticator Types a user may register. This allows the organization to ensure that only approved Authenticator Types which conform to the organization’s security policy are registered.</p>
                        <p>To create a registration policy, select the Application just added in <a href="#creatingAnApplication">Section 2.2</a> and select the “Policies” tab on the left. Next click the “Create Policy” button, selecting “FIDO Registration” from the drop down list shown when “Create Policy” is clicked.</p>
                        <center>
                            <a href="#figure8" class="openModal">
                                <img id="imageresource" src="images/large/Create_the_Registration_Policy.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 8: Create the Registration Policy (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Enter a unique Policy ID and the description can be left blank. Next click on the “Authenticator Types” tab and click “Add Allowed Group”.</p>
                        <center>
                            <a href="#figure9" class="openModal">
                                <img id="imageresource" src="images/large/Add_an_Authenticator_Type_Group.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 9: Add an Authenticator Type Group (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>To add an Authenticator Type to the Group, type the name of the Authenticator Type into the dialog box and you will be prompted with a list of matched Authenticator Types.</p>
                        <p>Once the Authenticator Type has been added, click “Save” to accept this Authenticator Type as an acceptable stand-alone Authenticator Type.</p>
                        <p>Once the Authenticator Type has been added, click “Save” to accept this Authenticator Type as an acceptable stand-alone Authenticator Type.</p>
                        <p><strong>NOTE:</strong> If more than one Authenticator Type is added to an Allowed Group then the user must register both Authenticator Types <em>at the same time, on the same device!</em> This represents the concept of AND for Authenticator Types that is, an Allowed Group means the first Authenticator Type in the group AND the second Authenticator Type AND the third Authenticator Type, etc. The concept of OR is represented by having multiple Allowed Groups that is, the Authenticator Type in the first group OR the Authenticator Types in the second group OR the Authenticator Types in the third group, etc.</p>
                        <center>
                            <a href="#figure10" class="openModal">
                                <img id="imageresource" src="images/large/Sample_Registration_Policy.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 10: Sample Registration Policy (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Once all the allowed Authenticator Types have been added to the policy, click “Create” to create the policy.</p>
                        <p>Note the name of the registration policy.</p>
                        <h2>2.5 Creating the Authentication Policy</h2>
                        <p>An Authentication Policy determines which Authenticator Types a user may use in an authentication process. This allows the organization to ensure that only approved Authenticator Types which conform to the organization’s security policy are used to authenticate the user.</p>
                        <p>The process of creating an Authentication Policy is identical to the process of creating a Registration Policy, so now create an Authentication Policy. The Authentication Policy should contain all or a subset of the Authenticator Types allowed in the corresponding Registration Policy.</p>
                        <p>Note the name of the Authentication Policy.</p>
                        <p><strong>NOTE:</strong> It is possible to use a registration policy as an Authentication Policy and vice versa. </p>
                        <p></p>
                        <a name="creatingAToken"></a>
                        <h2>2.6 Creating a Token</h2>
                        <p>In order for a Relying Party Server Application to connect to IdentityX it must have a token. A token is a cryptographic key shared between IdentityX and the Relying Party Server Application. The key is used by the Relying Party Server Application to sign the requests to and verify the responses from IdentityX. This is a key security feature of IdentityX and ensures that only properly authenticated applications may send messages to IdentityX.</p>
                        <p>Each token has an associated set of permissions within IdentityX. These permissions determine the capability of the Relying Party Server Application. In addition to verifying the signature on the request from a Relying Party Server Application, IdentityX will check that the token associated with the signature has the appropriate permission to perform the operation on the resource or resources. </p>
                        <p>To allow the Sample Relying Party Server Application to send requests to IdentityX a new token must be created. A further security feature of IdentityX is that IdentityX will only return a key encrypted under a public key sent during the token creation process. This is to ensure that no man-in-the middle attacks can intercept the token during the process of transfer. Thus to create a token a wrapping key is required.</p>
                        <h3>2.6.1   Create the wrapping key</h3>
                        <p>To generate the wrapping key, the Java keytool can be used with the following command (note that this does require a modern JDK or JRE to be installed and for unlimited strength security to be applied):</p>
                        <p><pre><code>keytool -genkeypair -alias identityxCert -keyalg RSA -keysize 2048 -dname "cn=SampleApp,ou=Dev,ou=RP,c=US" -storepass {password1} -keypass {password2} -keystore IdentityXKeyWrapper.jks</code></pre></p>
                        <p><strong>NOTE:</strong> it is not required to provide different passwords to the key store and the key within the key store. This example is provided for completeness. Specifying the password to the storepass will result in the same password being used for both.</p>
                        <h3>2.6.2   Extract the public key (as a cert)</h3>
                        <p>To create the token, the public key in the form of a certificate is required by the Admin Console. To retrieve the self-signed certificate from the key store, use the Java keytool with the following command:</p>
                        <p><pre><code>keytool -exportcert -alias identityxCert -storepass {password1} -keypass {password2} -file IdentityXCert.pem -rfc -keystore IdentityXKeyWrapper.jks</code></pre></p>
                        <p>This will extract the self-signed certificate from the key store in a PEM encoded format and store it in the file <em>IdentityXCert.pem</em>.</p>
                        <h3>2.6.3   Create the Token</h3>
                        <p>To create a token, logon to the Admin Console and select the “Tokens” item under “Administration” and click “Create Permanent Token”. The following screen will appear.</p>
                        <center>
                            <a href="#figure11" class="openModal">
                                <img id="imageresource" src="images/large/Create_New_Token.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 11: Create New Token (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Enter a “Subject ID” for the token and click the “Browse” button. Navigate to the location of the certificate file (<em>IdentityXCert.pem</em>) created earlier and close the dialog.</p>
                        <p>Next set the expiration at 10+ years into the future.</p>
                        <p>On the Permissions section, click “Add Permission”. A new line will be added to the Permissions table. For simplicity enter the following settings:</p>
                        <ul style="list-style-type:circle">
                            <li>Permission Selector: select the tenant (item in the list under “Tenants”)</li>
                            <li>Entity: select All(*)</li>
                            <li>CREATE: click the box</li>
                            <li>READ: click the box</li>
                            <li>UPDATE: click the box</li>
                            <li>DELETE: click the box</li>
                            <li>ALL(*): this will be automatically selected</li>
                        </ul>
                        <p>The screen should be similar to that displayed in Figure 12 - Creating the New Token.</p>
                        <center>
                            <a href="#figure12" class="openModal">
                                <img id="imageresource" src="images/large/Create_New_Token.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 12: Creating the New Token (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <p>Click “Submit” to have the token created. When the server responds, a dialog will be displayed where the browser requests a file with a default name of <em>credential.properties</em> be saved. Save the file locally.</p>
                        <p>This file (<em>credential.properties</em>) contains a number of important properties which will be used when connecting programmatically to IdentityX. This file should not need to be altered. Here is a description of the fields in the file:</p>
                        <ul style="list-style-type:circle">
                            <li>sharedKeyId – the Id of the token</li>
                            <li>encryptedSharedKey – the token key encrypted under the public key provided in the uploaded certificate</li>
                            <li>created – the date the token was created</li>
                            <li>expiration – the date the token will expire</li>
                            <li>subjectId – the name of the token</li>
                            <li>tenant – the URL of the tenant in which this token was created</li>
                            <li>systemUrl – the location of the system</li>
                        </ul>
                        <p>This file and the key store file created in Step 1 will be required by the Sample Relying Party Server Application.</p>
                    </div>
                </div>
                <!-- ADMIN CONSOLE -->
                <!-- PROGRAMMING IDENTITYX -->
                <a name="programmingIdentityX"></a>
                <div class="row">
                    <div class="col-lg-12">
                        <h1>3. Programming IdentityX</h1>
                        <p>After completing Section 2, the Application, Authenticator Types, Registration Policy, Authentication Policy and Token have been created within IdentityX.</p>
                        <p>IdentityX exposes its FIDO capabilities through a REST interface with JSON formatted messages. In the interactions below, the messages to be sent to and the messages received from the IdentityX server will be described.</p>
                        <p>Daon provides Java and JavaScript SDKs for interacting with the IdentityX Server. For the interactions below, message samples are provided and the corresponding Java code is also shown. The sample code is taken from the Java Sample Relying Party Server Application.</p>
                        <p>In this section, the process for connecting to IdentityX will be described as well as the requests and code necessary to find the entities created by the Admin Console in IdentityX. </p>
                        <p>Figure 13 - Class Model after Admin Console shows the state of the entity model after creating the entities in the Admin Console. </p>
                        <p>The items in green were created through the UI and the entities in blue will be created programmatically. However to create the entities in blue, it will be necessary to programmatically locate or find the green entities within IdentityX. This section describes how to locate these entities.</p>
                        <center>
                            <a href="#figure13" class="openModal">
                                <img id="imageresource" src="images/large/Class_Model_after_Creating_Entities_in_Admin_Console.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 13: Class Model after Creating Entities in Admin Console (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <h2>3.1 HRef and Resource Identifiers</h2>
                        <p>All entities within IdentityX have an associated <em>href</em> and <em>id</em>. Generally the <em>href</em> is used in calls to IdentityX to identify the entities. The <em>href</em> is derived from the unique identifier of the entity (the id) and the location of the IdentityX em and the entity type. The following is the format of the <em>href</em>:</p>
                        <p><pre><code>scheme://tenant_identifier.sys_dns_identifier/IdentityXServices/rest/v1/entityType/entityIdentifier</code></pre></p>
                        <ul style="list-style-type:circle">
                            <li><em>Scheme</em> – http or https</li>
                            <li><em>tenant_identifier</em> – provided by the IdentityX system administrator</li>
                            <li><em>system_dns_identifier</em> – the DNS identifier of the IdentityX system</li>
                            <li><em>entityType</em> – the entity type, for example, users, applications, policies etc.</li>
                            <li><em>entityIdentifier</em> – the id of the resource</li>
                        </ul>
                        <p><strong>NOTE:</strong> It is <strong>strongly</strong> recommended that if external systems are storing the identifiers of IdentityX entities, that the <em>entityId</em> or <em>id</em> of the entity is stored rather than the href as the <em>href</em> may change over time as the system location and version of IdentityX may change.</p>
                        <h2>3.2 Connecting to IdentityX with Java</h2>
                        <p>To connect to the IdentityX server using the Java SDK, a <em>TenantRepoFactory</em> object must be created. In order to create this object, the <em>credential.properties</em> file and the Java key store created in <a href="#adminConsole">Section 2 are required.  The code to create the <em>TenantRepoFactory</em> is as follows:</p>
                        <pre><code class="java">
public void connectToIdentityXServer() {
  try {
    EncryptedKeyPropFileCredentialsProvider provider = new EncryptedKeyPropFileCredentialsProvider(
                this.getKeystoreLocation(),              // location of the key store
                this.getKeystorePassword(),              // password to the key store
                this.getCredentialPropertiesLocation(),  // location of the credential.properties
                this.getKeystoreKeyAlias(),              // name of the key in the key store
                this.getKeystoreKeyPassword());          // password to the key in the key store
    tenantRepoFactory = new TenantRepoFactory(provider);
    logger.info("Connected to the IdentityX Server");
  } catch (Exception ex) {
    String error = "An exception occurred while attempting to connect to IdentityX.  Exception: "
                + ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre>
                        <p>The location of the IdentityX system, that is, its URL is contained in the <em>credential.properties</em> file.  Thus if at any stage the location of the IdentityX server should change, the <em>credential.properties</em> file must be updated with the new location.</p>
                        <p>The Java SDK will automatically sign requests to and verify responses from the server using the shared keys established when the token was created.</p>

                        <h2>3.3 Connecting to IdentityX with other languages</h2>
                        <p>In many of the examples below, sample REST requests are provided in addition to the Java SDK sample code.  REST requests cannot be sent to the IdentityX server without the associated signature.  Daon has provided documentation and sample Java code for creating the signature on a REST request and for verifying the signature on the response from the server.  This code can be ported to other languages to enable communication to the IdentityX server from those languages.</p>
                        
                        <h2>3.4 Finding the Application and Policies in IdentityX</h2>
                        <p>In order to use the Application and Policies created in the previous section within the application, the application will need to find these entities within IdentityX.</p>
                        
                        <h3>3.4.1   Finding the Application</h3>
                        <p>Since the Application will be used over and over again, it makes sense to “find” the Application once and then hold onto that application for the duration of the processing.  </p>
                        <p>To find an Application within IdentityX, a GET operation is sent to the URL:</p>
                        <p><pre><code>  https://tenant.domain.com/IdentityXServices/rest/v1/applications?applicationId={value}</code></pre></p>
                        <p><strong>Parameter</strong></p>
                        <p><em>applicationId</em>: This is a wildcard search parameter but if the exact <em>applicationId</em> is passed then the actual Application entity will be returned.</p>
                        <p><strong>Response</strong></p>
                        <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications?applicationId={value}",
    "metadata": {
        "limit": 10,
        "page": 1,
        "totalCount": 1
    },
    "paging": {
        "first": null,
        "last": null,
        "first": null,
        "last": null
    },
    "items": [
        {
          "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1",
          "id": "app1",
          "applicationId": "SampleApplication",
          …
        }
    ]
}
                        </code></pre></p>
                        <p>To find a specific application with the Java SDK, the following code snippet can be used:</p>
                        <p><pre><code class="java">
public Application findApplication(String applicationId) throws IdxRestException {

  ApplicationRepository applicationRepo = tenantRepoFactory.getApplicationRepo();
  ApplicationQueryHolder holder = new ApplicationQueryHolder();
  holder.getSearchSpec().setApplicationId(applicationId);
  ApplicationCollection applicationCollection = applicationRepo.list(holder);

  switch (applicationCollection.getItems().length) {
    case 0:
      throw new RuntimeException("Could not find an application with the ApplicationId: " +
          this.getApplicationId());
    case 1:
      return applicationCollection.getItems()[0];
    default:
      throw new RuntimeException("There is more than one application with the same ApplicationId!" +
                 "This is not possible");
  }
}
                        </code></pre></p>
                        
                        <h3>3.4.2   Finding the Registration/Authentication Policy</h3>
                        <p>Since the registration/Authentication Policy will be used over and over again, it makes sense to “find” the registration/Authentication Policy once and then hold onto that registration/Authentication Policy for the duration of the processing.</p>
                        <p>To find a Policy within IdentityX, a GET operation is sent to the URL:</p>
                        <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/policies?policyId={value}</code></pre></p>
                        <p><strong>Parameter</strong></p>
                        <p><em>policyId</em>: This is a wildcard search parameter but if the exact policyId is passed then the actual Policy entity will be returned.</p>
                        <p><strong>Response</strong></p>
                        <p>The response will be a collection of policies with 0 or more policies returned:</p>
                        <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies?policyId={value}",
    "metadata": {
        "limit": 10,
        "page": 1,
        "totalCount": 1
    },
    "paging": {
        "first": null,
        "last": null,
        "first": null,
        "last": null
    },
    "items": [
        {
          "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/regPol1",
          "id": "regPol1",
          "policyId": "RegPolicy",
          …
        }
    ]
}
                        </code></pre></p>
                        <p>To find a specific registration/Authentication Policy with the Java SDK, the following code snippet can be used: </p>
                        <p><pre><code class="java">
public Policy findPolicy(String policyId) throws IdxRestException {

  PolicyQueryHolder holder = new PolicyQueryHolder();
  holder.getSearchSpec().setPolicyId(policyId);
  PolicyRepository policyRepo = this.getTenantRepoFactory().getPolicyRepo();
  PolicyCollection policyCollection = policyRepo.list(this.getApplication().getPolicies().getHref(),
                                      holder);
  switch (policyCollection.getItems().length) {
    case 0:
      throw new RuntimeException("Could not find a policy with the PolicyId: " + policyId);
    case 1:
      return policyCollection.getItems()[0];
    default:
      throw new RuntimeException("There is more than one policy with the name: " + policyId);
  }
}
                        </code></pre></p>
                    </div>
                </div>
<!-- PROGRAMMING IDENTITYX -->
                        
<!-- CREATING ENTITIES -->
                <a name="creatingEntities"></a>
                            <div class="row">
                                <div class="col-lg-12">
                                    <h1>4.  Creating Entities</h1>
                                    <p>The next stage of integration is the creation of entities within IdentityX. This section will cover the requests necessary to manage Users and Registrations.</p>
                                    <p>These entities are shown in Figure 14 - Class Model - Users and Registrations.</p>
                                    <h2>4.1 Class Model - Users and Registrations</h2>
                                    <center>
                                        <a href="#figure14" class="openModal">
                                            <img id="imageresource" src="images/large/Class_Model_Users_and_Registrations.png" style="width: 70%;border:1px solid black">
                                            <br />
                                            <figcaption>Figure 14: Class Model – Users and Registrations (click to enlarge)</figcaption>
                                        </a>
                                    </center>
                                    <h2>4.2 Users</h2>
                                    <h3>4.2.1   Creating a User</h3>
                                    <p>Creating a User within IdentityX is performed through the REST APIs by POSTing a User object to the URL:</p>
                                    <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/users</code></pre></p>
                                    <p>A User object must contain at a minimum the <em>userId</em> attribute:</p>
                                    <p><pre><code class="json">
{
    "userId": "John.Smith@mail.com"
}
                        </code></pre></p>
                                    <p>And the <em>userId</em> must be unique within IdentityX. The <em>userId</em> is important in FIDO as it is the <em>“username”</em> field passed to the FIDO Client and Authenticator and as such displayed to the user.</p>
                                    <p>This will, if successful, return a newly created User with many additional attributes as follows:</p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1",
    "id": "user1",
    "userId": "John.Smith@mail.com"
    …
}
                        </code></pre></p>
                                    <p>The important attributes to note here are the <em>id</em> and the <em>href</em>. The <em>href</em> will be used in subsequent calls to IdentityX.</p>
                                    <p>With the Java SDK, the user can be created with the Java SDK as follows: </p>
                                    <p><pre><code class="java">
public User addUser(String userId) throws IdxRestException {
  UserRepository userRepo = this.getTenantRepoFactory().getUserRepo();
  User aUser = new User();
  aUser.setUserId(userId);
  aUser = userRepo.create(aUser);
  return aUser;
}
                        </code></pre></p>
                                    <h3>4.2.2   Finding a User</h3>
                                    <p>To find a User within IdentityX, a GET operation is sent to the URL:</p>
                                    <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/users?userId={value}</code></pre></p>
                                    <p><strong>Parameter</strong></p>
                                    <p><em>userId</em>: This is a wildcard search parameter but if the exact userId is passed then the actual user entity will be returned.</p>
                                    <p><strong>Response</strong></p>
                                    <p>The response will be a collection of users with 0 or more users returned:</p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users?userId={value}",
    "metadata": {
        "limit": 10,
        "page": 1,
        "totalCount": 1
    },
    "paging": {
        "first": null,
        "last": null,
        "first": null,
        "last": null
    },
    "items": [
        {
          "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1",
          "id": "user1",
          "userId": "John.Smith@mail.com",
          …
        }
    ]
}
                        </code></pre></p>
                                    <p>To find a specific user with the Java SDK, the following code snippet can be used: </p>
                                    <p><pre><code class="java">
public User findUser(String userId) throws IdxRestException {

  UserRepository userRepo = this.getTenantRepoFactory().getUserRepo();
  UserQueryHolder holder = new UserQueryHolder();
  UserSearchSpec spec = holder.getSearchSpec();
  spec.setUserId(userId);
  holder.setSearchSpec(spec);
  UserCollection userCollection = userRepo.list(holder);
  switch (userCollection.getItems().length) {
    case 0:
      return null;
    case 1:
      return userCollection.getItems()[0];
    default:
      throw new RuntimeException("More than one user with the same UserId!!!!");
  }
}
                        </code></pre></p>
                                    <h3>4.2.3   Archiving a User</h3>
                                    <p>To archive (permanently deactivate) a user within IdentityX, a POST operation is sent to the following URL:</p>
                                    <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/users/{id}/archived</code></pre></p>
                                    <p>where <em>id</em> is the id of the user.</p>
                                    <p>To archive a user with the Java SDK, the following code snippet can be used:</p>
                                    <p><pre><code class="java">
public User archiveUser(String userId) throws IdxRestException {

  try {
    User user = this.findUser(userId);
    if (user == null) {
      logger.debug("Nothing to do - the user does not exist in IdentityX");
      return;
    } else {
      UserRepository userRepo = this.getTenantRepoFactory().getUserRepo();
      userRepo.archive(user);
    }
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to archive the user: " + userId +
         ".  Exception: " + ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <h2>4.3 Registrations</h2>
                                    <h3>4.3.1   Creating a Registration</h3>
                                    <p>Creating a Registration within IdentityX is performed through the REST APIs by POSTing a Registration object to the URL:</p>
                                    <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/registrations</code></pre></p>
                                    <p><strong>Request</strong></p>
                                    <p>A Registration object must contain the <em>user</em>, the <em>application</em> and the <em>registrationId</em> attributes:</p>
                                    <p><pre><code class="json">
{
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "registrationId": "John.Smith@mail.com"
}
                        </code></pre></p>
                                    <p>And the <em>registrationId</em> must be unique within the application.</p>
                                    <p><strong>Response</strong></p>
                                    <p>This will, if successful, return a newly created Registration with many additional attributes as follows:</p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrations/reg1",
    "id": "reg1",
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    …
}
                        </code></pre></p>
                                    <p>The important attributes to note here are the <em>id</em> and the <em>href</em>. The <em>href</em> will be used in subsequent calls to IdentityX but the <em>id</em> can be stored if required.</p>
                                    <p>With the Java SDK, this can be achieved with:</p>
                                    <p><pre><code class="java">
public Registration addRegistration(User user, String registrationId) throws IdxRestException {

  RegistrationRepository regRepo = this.getTenantRepoFactory().getRegistrationRepo();
  Registration reg = new Registration();
  reg.setUser(user);
  reg.setApplication(this.getApplication());
  reg.setRegistrationId(registrationId);
  reg = regRepo.create(reg);
  return reg;
}
                        </code></pre></p>
                                    <h3>4.3.2   Finding a Registration</h3>
                                    <p>To find a Registration associated with a user within IdentityX, a GET operation is sent to the URL: </p>
                                    <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/users/{id}/registrations?registrationId={value}</code></pre></p>
                                    <p><strong>Parameter</strong></p>
                                    <p><em>id</em>: This is the unique identifier of the user. </p>
                                    <p><em>registrationId</em>: This is a wildcard search parameter but if the exact <em>registrationId</em> is passed then the actual registration entity will be returned, if it exists.</p>
                                    <p><strong>Response</strong></p>
                                    <p>The response will be a collection of registrations with 0 or more registrations returned:</p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/sdfsdf/registrations?registraionId={value}",
    "metadata": {
        "limit": 10,
        "page": 1,
        "totalCount": 1
    },
    "paging": {
        "first": null,
        "last": null,
        "first": null,
        "last": null
    },
    "items": [
        {
          "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrations/reg1",
          "id": "reg1",
          "application": {
              "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
          },
          "user": {
              "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
          },
          …
        }
    ]
}
                        </code></pre></p>
                                    <p>To find a specific registration associated with a user with the Java SDK, the following code snippet can be used: </p>
                                    <p><pre><code class="java">
public Registration findRegistration(User user, String registrationId) throws IdxRestException {

  RegistrationRepository regRepo = this.getTenantRepoFactory().getRegistrationRepo();
  RegistrationQueryHolder holder = new RegistrationQueryHolder();
  holder.getSearchSpec().setRegistrationId(registrationId);
  RegistrationCollection registrationCollection = regRepo.list(user.getRegistrations().getHref(), holder);
  switch (registrationCollection.getItems().length) {
    case 0:
      return null;
    case 1:
      return registrationCollection.getItems()[0];
    default:
      throw new RuntimeException("More than one registration with the same RegistrationId!!!!");
  }
}
                        </code></pre></p>
                                    <h3>4.3.3   Archiving a Registration</h3>
                                    <p>To archive or permanently deactivate a registration within IdentityX, a POST operation is sent to the following URL:</p>
                                    <p><pre><code>https://tenant.domain.com/IdentityXServices/rest/v1/registrations/{id}/archived</code></pre></p>
                                    <p>where <em>id</em> is the id of the registration.</p>
                                    <p>To archive a registration with the Java SDK, the following code snippet can be used: </p>
                                    <p><pre><code class="java">
protected void archiveRegistration(User user, String registrationId) throws IdxRestException {

  Registration registration = this.findRegistration(user, registrationId);
  if (registration == null) {
    logger.debug("Nothing to do - the registration does not exist or is already archived");
  } else {
    RegistrationRepository regRepo = this.getTenantRepoFactory().getRegistrationRepo();
    regRepo.archive(registration);
  }
}
                        </code></pre></p>
                                </div>
                            </div>
                            <!-- CREATING ENTITIES -->
                            <!-- REGISTRATION -->
                            <a name="registration"></a>
                            <div class="row">
                                <div class="col-lg-12">
                                    <h1>5.  Registration</h1>
                                    <p>Once a user and a registration have been created within IdentityX, the next step is to enable that user as a FIDO user. This involves the creation of a <em>RegistrationChallenge</em> and an <em>Authenticator</em> as shown in Figure 15 - Class Model - Registration Challenges and Authenticators.</p>
                                    <h2>5.1 Class Model - Registration Challenges and Authenticators</h2>
                                    <center>
                                        <a href="#figure15" class="openModal">
                                            <img id="imageresource" src="images/large/Class_Model_Registration_Challenges_and_Authenticators.png" style="width: 70%;border:1px solid black">
                                            <br />
                                            <figcaption>Figure 15: Class Model – Registration Challenges and Authenticators (click to enlarge)</figcaption>
                                        </a>
                                    </center>
                                    <p>However, creating the entities within IdentityX is not sufficient. There needs to be a corresponding interaction with a FIDO Client and authenticator on the user’s device. The sequence of operations involved is shown in Figure 16 - Registration Process.</p>
                                    <center>
                                        <a href="#figure16" class="openModal">
                                            <img id="imageresource" src="images/large/Registration_Process.png" style="width: 70%;border:1px solid black">
                                            <br />
                                            <figcaption>Figure 16: Registration Process (click to enlarge)</figcaption>
                                        </a>
                                    </center>
                                    <p>Figure 16 - Registration Process shows the response from the POST operation to IdentityX to create a <em>RegistrationChallenge</em> returning the <em>fidoRegistrationRequest</em> and <em>HREF</em>. These are returned as part of the <em>RegistrationChallenge</em> object from IdentityX. The RPSA then extracts these attributes and returns them as part of a new JSON object (<em>CreateAccountResponse</em> or <em>CreateRegRequestResponse</em>) to the RPApp.</p>
                                    <p>In a similar fashion, the process of updating the <em>RegistrationChallenge</em> in IdentityX shows the return of the <em>fidoRegRepCode</em> and <em>fidoRegRespMessage</em>. These are attributes returned as part of the updated <em>RegistrationChallenge</em> object from IdentityX. The RPSA then extracts these attributes and returns them as part of a new JSON object (<em>CreateAuthenticatorResponse</em>) to the RPApp.</p>
                                    <p>The sections below describe the integration with IdentityX to support the creation of the <em>RegistrationChallenge</em> and the <em>Authenticator</em>. The Sample Android Relying Party App and Sample Relying Party Server Application provide an end to end implementation of this sequence.</p>
                                    <h2>5.2 Creating a Registration Challenge</h2>
                                    <p>Creating a Registration Challenge within IdentityX is performed through the REST APIs by POSTing a Registration Challenge object to the URL </p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/registrationChallenges
{
    "registration": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrations/reg1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/regPolicy1"
    }
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrationChallenges/regChallenge1",
    "id": "regChallenge1",
    "registration": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrations/reg1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/regPolicy1"
    },
    "fidoRegistrationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Reg"}]...",
    "fidoRegistrationResponse": null,

    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
protected RegistrationChallenge addRegistrationChallenge(Registration reg) throws IdxRestException {

  RegistrationChallengeRepository regChallengeRepository =  
       this.getTenantRepoFactory().getRegistrationChallengeRepo();
  RegistrationChallenge regChallenge = new RegistrationChallenge();
  regChallenge.setRegistration(reg);
  regChallenge.setPolicy(this.getRegPolicy());
  regChallenge = regChallengeRepository.create(regChallenge);
  return regChallenge;
}
                        </code></pre></p>
                                    <p><strong>Processing the Response</strong></p>
                                    <p>The important attributes to note here are the <em>id</em>, the <em>href</em> and the <em>fidoRegistrationRequest</em>.</p>
                                    <ul>
                                        <li><em>Href</em>: This will be used in subsequent calls to IdentityX.</li>
                                        <li><em>Id</em>: This can be stored if required</li>
                                        <li><em>fidoRegistrationRequest</em>: This is to be sent to the user’s device where it is to be passed to the FIDO client. </li>
                                    </ul>
                                    <p>In the sample FIDO application supplied by Daon, the <em>href</em> and the <em>fidoRegistrationRequest</em> are sent, via the Relying Party Server Application to the App. The App calls the FIDO Client passing in the <em>fidoRegistrationRequest</em>. </p>
                                    <p>Once the <em>fidoRegistrationRequest</em> is sent to the FIDO Client, the user will be asked to accept the registration by either a) register to the authenticator(s) or b) verify on the authenticator(s). </p>
                                    <p>Assuming a successful registration by the user, the FIDO client will return a <em>fidoRegistrationResponse</em>, this response and the HREF are sent to the Relying Party Server Application which calls the FIDO Server.</p>
                                    <h2>5.3 Processing the Registration Response</h2>
                                    <p>To have the FIDO Server process the <em>fidoRegistrationResponse</em> from the FIDO Client, the specific <em>RegistrationChallenge</em> must be updated setting the <em>fidoRegistrationResponse</em> to the value returned from the FIDO Client. If this process is successful, it will result in one or more <em>Authenticators</em> being created in IdentityX.</p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/registrationChallenges/regChallenge1
{
    "fidoRegistrationResponse": "[{"assertions": [...}]"
}

                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrationChallenges/regChallenge1",
    "id": "regChallenge1",
    "registration": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrations/reg1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/regPolicy1"
    },
    "fidoRegistrationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Reg"}]...",
    "fidoRegistrationResponse": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Reg"}]...",
    "fidoResponseCode": 0,
    "fidoResponseMsg": "Message",
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public RegistrationChallenge processRegistrationResponse(String regChallengeHref,
        String fidoRegChallengeResponse) {

  try {
    RegistrationChallengeRepository regChallengeRepo =
        this.getTenantRepoFactory().getRegistrationChallengeRepo();
    RegistrationChallenge regChallenge = regChallengeRepo.get(regChallengeHref);
    if (regChallenge == null) {
      String error = "Unable to find the registration challenge with HREF: " + regChallengeHref;
      logger.error(error);
      throw new RuntimeException(error);
    }
    regChallenge.setFidoRegistrationResponse(fidoRegChallengeResponse);
    regChallenge = regChallengeRepo.update(regChallenge);
    return regChallenge;
  } catch (IdxRestException ex) {
  String error = "An exception occurred while attempting to update the registration challenge." + 
                "  Exception: " + ex.getMessage();
  logger.error(error, ex);
  throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p><strong>Processing the Response</strong></p>
                                    <p>The important attributes to note here are the <em>fidoRegResponseCode</em> and <em>fidoRegResponseMessage</em>.</p>
                                    <ul>
                                        <li><em>fidoRegResponseCode</em>: This is to send to the user’s device and from there to the FIDO client</li>
                                        <li><em>fidoRegResponseMessage</em>: This is to send to the user’s device and from there to the FIDO client</li>
                                    </ul>
                                    <p>If this request is successful, one or more <em>Authenticators</em> will have been created in IdentityX. However the registration process on the FIDO client is not completed until the <em>fidoRegResponse</em> and <em>fidoRegResponseMessage</em> are received from the FIDO Server. Thus the Relying Party Server Application must pass these values back from the FIDO Server to the FIDO Client via the Relying Party App.</p>
                                </div>
                            </div>
                            <!-- REGISTRATION -->
                            <!-- AUTHENTICATION -->
                            <a name="authentication"></a>
                            <div class="row">
                                <div class="col-lg-12">
                                    <h1>6.  Authentication</h1>
                                    <p>Once a <em>RegistrationChallenge</em> and an <em>Authenticator</em> have been created within IdentityX, the next step is to authenticate that user with FIDO. </p>
                                    <p>This involves the creation of an <em>AuthenticationRequest</em> and an <em>AuthenticationResponse</em> as shown in Figure 17 - Class Model - Authentication Request & Authentication . </p>
                                    <h2>6.1 Class Model - Authentication Request & Authentication Response</h2>
                                    <center>
                                        <a href="#figure17" class="openModal">
                                            <img id="imageresource" src="images/large/Class_Model_Authentication_Request_and_Authentication_Attempt.png" style="width: 70%;border:1px solid black">
                                            <br />
                                            <figcaption>Figure 17: Class Model – Authentication Request & Authentication Attempt (click to enlarge)</figcaption>
                                        </a>
                                    </center>
                                    <p>However, creating the entities within IdentityX is not sufficient. There needs to be a corresponding interaction with a FIDO Client and Authenticator on the user’s device. The sequence of operations involved is shown in Figure 18 - Authentication Process.</p>
                                    <p>The sections below describe the integration with IdentityX to support the creation of the <em>AuthenticationRequest</em> and the <em>AuthenticationAttempt</em>. The Sample Android Relying Party App and Sample Relying Party Server Application provide an end to end implementation of this sequence.</p>
                                    <center>
                                        <a href="#figure18" class="openModal">
                                            <img id="imageresource" src="images/large/Authentication_Process.png" style="width: 70%;border:1px solid black">
                                            <br />
                                            <figcaption>Figure 18: Authentication Process (click to enlarge)</figcaption>
                                        </a>
                                    </center>
                                    <p>Figure 18 - Authentication Process shows the response from the POST operation to create an <em>AuthenticationRequest</em> returning the <em>fidoAuthenticationRequest</em> and <em>HREF</em>. These are returned as part of the <em>AuthenticationRequest</em> object from IdentityX. In a similar fashion, the process of verifying the authentication request is performed by updating the <em>AuthenticationRequest</em>. The <em>AuthenticationRequest</em> object is returned after the update and the <em>status</em> on this object indicates whether the authentication has been successful.</p>
                                    <h2>6.2 Creating an Authentication Request</h2>
                                    <p>Creating an Authentication Request within IdentityX is performed through the REST APIs by POSTing an Authentication Request object:</p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests
{
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "description": "Server recorded authentication transaction",
    "type": "FI"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authRequest1",
    "id": "authRequest1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "description": "Server recorded authentication transaction",
    "type": "FI",
    "fidoAuthenticationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Auth"}]...",
    "fidoAuthenticationResponse": null,
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public AuthenticationRequest createAuthRequest() {

  try {
    AuthenticationRequest request = new AuthenticationRequest();
    request.setPolicy(this.getAuthPolicy());
    request.setApplication(this.getApplication());
    request.setDescription("Test transaction");
    request.setType("FI");
    AuthenticationRequestRepository authenticationRequestRepo =
            this.getTenantRepoFactory().getAuthenticationRequestRepo();
    request = authenticationRequestRepo.create(request);
    return request;
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to create an auth request." +
                   "  Exception: " + ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p><strong>Processing the Response</strong></p>
                                    <p>The important attributes to note here are the <em>id</em>, the <em>href</em> and the <em>fidoAuthenticationRequest</em>.</p>
                                    <ul>
                                        <li><em>Href</em>: This will be used in subsequent calls to IdentityX.</li>
                                        <li><em>id</em>: This can be stored if required.</li>
                                        <li><em>fidoAuthenticationRequest</em>: This is to be sent to the user’s device where it is to be passed to the FIDO client. </li>
                                    </ul>
                                    <p><strong>Note</strong></p>
                                    <p>In the sample FIDO application supplied by Daon, the <em>href</em> and the <em>fidoAuthenticationRequest</em> are sent, via the Relying Party Server Application to the App. The App calls the FIDO Client passing in the <em>fidoAuthenticationRequest</em>. </p>
                                    <p>Once the <em>fidoAuthenticationRequest</em> is sent to the FIDO client, the user will be asked to verify on the authenticator(s). </p>
                                    <p>Assuming a successful verification by the user, the FIDO client will return a <em>fidoAuthenticationResponse</em>, this response and the <em>href</em> are sent to the Relying Party Server Application which calls the FIDO Server.</p>
                                    <h2>6.3 Processing the Authentication Response</h2>
                                    <p>To have the FIDO Server process the <em>fidoAuthenticationResponse</em> from the FIDO Client, the specific <em>AuthenticationRequest</em> must be updated setting the <em>fidoAuthenticationResponse</em> to the value returned from the FIDO Client.</p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authRequest1
{
    "fidoAuthenticationResponse": "[{\"assertions\": [...}]"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrationChallenges/authRequest1",
    "id": "authRequest1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "registration": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/registrations/reg1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "fidoAuthenticationRequest": "[{\"header\": {\"upv\": {\"major\": 1,\"minor\": 0},\"op\": \"Auth"}]…",
    "fidoAuthenticationResponse": "[{\"assertions\": [...}]",
    "status": "COMPLETED_SUCCESSFUL",
    "user": {
      "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public AuthenticationRequest validateAuthResponse(String authenticationRequestHref, String authResponse) {

  try {
    AuthenticationRequestRepository authenticationRequestRepo = 
        this.getTenantRepoFactory().getAuthenticationRequestRepo();
    AuthenticationRequest request = authenticationRequestRepo.get(authenticationRequestHref);
    if (request == null) {
      String error = "Unable to find the authentication request with HREF: " + authenticationRequestHref;
      logger.error(error);
      throw new RuntimeException(error);
    }
    request.setFidoAuthenticationResponse(authResponse);
    request = authenticationRequestRepo.update(request);
    if (request.getStatus() == AuthenticationRequestStatusEnum.COMPLETED_SUCCESSFUL) {
      // Find the user from the local repository
      UserRepository userRepo = this.getTenantRepoFactory().getUserRepo();
      if (request.getUser() != null) {
        request.setUser(userRepo.get(request.getUser().getHref()));
      }
      return request;
    }
    String error = "Response could not be validated";
    logger.error(error);
    throw new RuntimeException(error);
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to update the registration challenge." + 
                   "  Exception: " + ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p><strong>Processing the Response</strong></p>
                                    <p>The important attributes to note here are the <em>status</em> and <em>user</em>:</p>
                                    <ul>
                                        <li><em>Status</em>: This determines if the response could be verified by the server</li>
                                        <li><em>user</em>: This is a reference to the actual user authenticated – if the status field is anything other than <em>COMPLETED_SUCCESSFULLY</em> then this field will NOT be set.</li>
                                    </ul>
                                    <p>If the status is any value other than <em>COMPLETED_SUCCESSFULLY</em>, the verification cannot be considered to have been successful. If the status is set to <em>COMPLETED_SUCCESSFULLY</em> then the <em>user</em> field will be set and the <em>user</em> object will be set to a <em>href</em> to the user who has been authenticated.</p>
                                </div>
                            </div>
                            <!-- AUTHENTICATION -->
                            <!-- DEREGISTRATION -->
                            <a name="deregistration"></a>
                            <div class="row">
                                <div class="col-lg-12">
                                    <h1>7.  De-registration</h1>
                                    <p>The process of de-registration is the process of removing the relationship between a user and an authenticator. This process may be:</p>
                                    <ol>
                                        <li>Initiated by a user, if permitted. The request must still go through the Relying Party Server Application</li>
                                        <li>Performed by an administrator through the Admin console</li>
                                        <li>Performed by the Relying Party Server Application through the IdentityX REST interface</li>
                                    </ol>
                                    <p>Deregistration is complex as it is a two phase process and it may not be possible to synchronize both phases.</p>
                                    <h2>7.1 Phase 1 – Deregistration in IdentityX</h2>
                                    <p>This is the first phase of the process and requires the change of state of a user’s FIDO authenticator on the FIDO server. In addition to changing the state, IdentityX will also generate a FIDO deregistration request which is a message for the FIDO Client on the machine with the authenticator. </p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticators/auth1/archived
{
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticators/auth1",
    "id": "auth1",
    "fidoDeregistrationRequest": "[{\"header\": {\"upv\": {\"major\": 1,\"minor\": 0},\"op\": \"Dereg\"}...]",
    "status": "ARCHIVED",
    "authenticatorType": {
      "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticatorTypes/authType1"
    },
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public String deleteAuthenticator(String fidoId, String authenticatorId) {
  try {
    AuthenticatorRepository authenticatorRepo = this.getTenantRepoFactory().getAuthenticatorRepo();
    Authenticator authenticator = authenticatorRepo.getById(authenticatorId);
    if (authenticator == null) {
      String error = "Unable to find the authenticator with ID: " + authenticatorId;
      logger.error(error);
      throw new RuntimeException(error);
    }
    authenticator = authenticatorRepo.archive(authenticator);
    return authenticator.getFidoDeregistrationRequest();
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to archive the authenticator.  Exception: " +
      ex.getMessage();
      logger.error(error, ex);
      throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p><strong>Processing the Response</strong></p>
                                    <p>The important attribute to note here is the <em>fidoDeregistrationRequest</em>.</p>
                                    <ul>
                                        <li><em>fidoDeregistrationRequest</em>: This value should be sent to the FIDO authenticator in order to remove the registration from the authenticator</li>
                                    </ul>
                                    <h2>7.2 Phase 2 – Deregistration on the Device</h2>
                                    <p>If the device is available then the <em>fidoDeregistrationRequest</em> from the server should be sent to the FIDO Client on the device with the registered authenticator. This is where the difficulty arises. The device may not be available during the deregistration process as an Administrator may be performing the deregistration on behalf of the user if a device is lost or stolen. Alternatively, a user may initiate a deregistration of an authenticator on one device from another device. In these instances, the registration will remain on the user’s authenticator and he/she may attempt to use that registration to re-authenticate to the RPSA. While the FIDO Specification does attempt to rectify this by passing a specific error code 1481 to the FIDO client, not all Clients and authenticators are able to handle this error code and delete the appropriate authenticator.</p>
                                </div>
                            </div>
                            <!-- DEREGISTRATION -->
                            <!-- TRANSACTION CONFIRMATION -->
                            <a name="transactionConfirmation"></a>
                            <div class="row">
                                <div class="col-lg-12">
                                    <h1>8.  Transaction Confirmation</h1>
                                    <p><a href="#authentication">Section 6</a> covers the basic flow of creating an authentication. The FIDO UAF Specification provides for two authentication types:</p>
                                    <ol>
                                        <li><strong>Open Authentication</strong>: This is the authentication described in the section on Authentication. The Relying Party Server Application requiring authentication does not know in advance who is being authenticated. After the authentication is complete, IdentityX reports to the Relying Party Server Application, the user who was authenticated.</li>
                                        <li><strong>Step-up Authentication</strong>: In this instance the Relying Party Server Application does know who it is trying to authenticate. The value of this approach is that the user is never prompted with a dialog requesting them to choose their identity. FIDO calls this "step-up” authentication as it can only occur after the Relying Party Server Application has had some confirmation as to the identity of the user. </li>
                                    </ol>
                                    <p>In addition to the two authentication types, the FIDO Specification also allows transaction confirmation where a “transaction” payload is included with an authentication request. This request will be sent to the device and displayed by the authenticator to the user. The transaction payload is then signed by the authenticator key (with the random challenge) and returned to the server where the signature is verified. This approach provides a means for the Relying Party Server Application to pass a message to the user and have confidence that the user has seen an unmodified version of the message as it was signed by the authenticator. </p>
                                    <p>Unfortunately not all authenticators support transaction confirmation. The two types of transaction confirmations are:</p>
                                    <ol>
                                        <li><strong>Text Transaction</strong>: In this instance the format of the transaction payload is a string</li>
                                        <li><strong>Image Transaction</strong>: In this instance the format of the transaction payload is an image (PNG)</li>
                                    </ol>
                                    <h2>8.1 Open & Step-up Authentication</h2>
                                    <p>The process of creating a step-up authentication is identical to that for creating an open authentication request except the user must be specified in the request.</p>
                                    <p>Creating a Step-up Authentication Request within IdentityX is performed through the REST APIs by POSTing an Authentication Request object.</p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests
{
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },

    "description": "Server recorded step-up authentication transaction",
    "type": "FI"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authReq1",
    "id": "authReq1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "description": "Server recorded step-up authentication transaction",
    "type": "FI",
    "fidoAuthenticationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Auth"}]...",
    "fidoAuthenticationResponse": null,
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public AuthenticationRequest createStepUpAuthRequest(User aUser) {

  try {
    AuthenticationRequest request = new AuthenticationRequest();
    request.setPolicy(this.getAuthPolicy());
    request.setApplication(this.getApplication());
    request.setUser(aUser);
    request.setDescription("Test transaction");
    request.setType("FI");
    AuthenticationRequestRepository authenticationRequestRepo =
            this.getTenantRepoFactory().getAuthenticationRequestRepo();
    request = authenticationRequestRepo.create(request);
    return request;
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to create an auth request.  Exception: " +
        ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p>The process for verifying the transaction is identical to that shown in the section on <a href="#authentication">Authentication</a>.</p>
                                    <h2>8.2 Text based Transaction Confirmation</h2>
                                    <p>The process of creating a text based transaction confirmation (as it is known by FIDO) is identical to that for creating an open or step-up authentication request except the secure transaction text must be specified.</p>
                                    <p>Creating a text based transaction confirmation within IdentityX is performed through the REST APIs by POSTing an Authentication Request object: </p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests
{
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "description": "Server recorded text based transaction confirmation",
    "secureTransactionContentType": "text/plain",
    "secureTransactionContent": "This is the secure content",
    "type": "FI"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authReq1",
    "id": "authReq1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "description": "Server recorded step-up authentication transaction",
    "secureTransactionContentType": "text/plain",
    "secureTransactionContent": "This is the secure content",
    "type": "FI",
    "fidoAuthenticationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Auth"}]...",
    "fidoAuthenticationResponse": null,
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public AuthenticationRequest createTextBasedTransactionConfirmation(String confirmationText) {

  try {
    AuthenticationRequest request = new AuthenticationRequest();
    request.setPolicy(this.getAuthPolicy());
    request.setApplication(this.getApplication());
    request.setDescription("Test transaction");
    request.setSecureTransactionContentType("text/plain");
    request.setSecureTransactionContent(confirmationText);
    request.setType("FI");
    AuthenticationRequestRepository authenticationRequestRepo =
            this.getTenantRepoFactory().getAuthenticationRequestRepo();
    request = authenticationRequestRepo.create(request);
    return request;
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to create an auth request.  Exception: " +
        ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p>The process for verifying the transaction is identical to that shown in the section on <a href="#authentication">Authentication</a>.</p>
                                    <p>The example above shows the process of creating an open authentication with text transaction confirmation. To create a step-up authentication with transaction confirmation the user must be specified in the requests as shown below:</p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests
{
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "description": "Server recorded text based transaction confirmation",
    "secureTransactionContentType": "text/plain",
    "secureTransactionContent": "This is the secure content",
    "type": "FI"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authReq1",
    "id": "authReq1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "description": "Server recorded step-up authentication transaction",
    "secureTransactionContentType": "text/plain",
    "secureTransactionContent": "This is the secure content",
    "type": "FI",
    "fidoAuthenticationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Auth"}]...",
    "fidoAuthenticationResponse": null,
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with:</p>
                                    <p><pre><code class="java">
public AuthenticationRequest createTextBasedTransactionConfirmation(User aUser, String confirmationText) {

  try {
    AuthenticationRequest request = new AuthenticationRequest();
    request.setPolicy(this.getAuthPolicy());
    request.setApplication(this.getApplication());
    request.setUser(aUser);
    request.setDescription("Test transaction");
    request.setSecureTransactionContentType("text/plain");
    request.setSecureTransactionContent(confirmationText);
    request.setType("FI");
    AuthenticationRequestRepository authenticationRequestRepo =
            this.getTenantRepoFactory().getAuthenticationRequestRepo();
    request = authenticationRequestRepo.create(request);
    return request;
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to create an auth request.  Exception: " +
        ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <h2>8.3 Image based Transaction Confirmation</h2>
                                    <p>The process of creating an image based transaction confirmation (as it is known by FIDO) is identical to that for creating an open or step-up authentication request except the secure transaction image must be specified.</p>
                                    <p>Creating an image based transaction confirmation within IdentityX is performed through the REST APIs by POSTing an Authentication Request object </p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests
{
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "description": "Server recorded text based transaction confirmation",
    "secureTransactionContentType": "image/png",
    "secureTransactionContent": "aaaa...",                // base64 of the image
    "type": "FI"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authReq1",
    "id": "authReq1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "description": "Server recorded step-up authentication transaction",
    "secureTransactionContentType": "image/png",
    "secureTransactionContent": "aaaa...",                // base64 of the image
    "type": "FI",
    "fidoAuthenticationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Auth"}]...",
    "fidoAuthenticationResponse": null,
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java">
public AuthenticationRequest createImageBasedTransactionConfirmation(String confirmationImaseAsBase64) {

  try {
    AuthenticationRequest request = new AuthenticationRequest();
    request.setPolicy(this.getAuthPolicy());
    request.setApplication(this.getApplication());
    request.setDescription("Test transaction");
    request.setSecureTransactionContentType("text/plain");
    request.setSecureTransactionContent(confirmationImaseAsBase64);
    request.setType("FI");
    AuthenticationRequestRepository authenticationRequestRepo =
            this.getTenantRepoFactory().getAuthenticationRequestRepo();
    request = authenticationRequestRepo.create(request);
    return request;
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to create an auth request.  Exception: " +
        ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                    <p>The process for verifying the transaction is identical to that shown in the section on <a href="#authentication">Authentication</a>.</p>
                                    <p>The example above shows the process of creating an open authentication with text transaction confirmation. To create a step-up authentication with transaction confirmation the user must be specified in the requests as shown below:</p>
                                    <p><pre><code class="json">
POST https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests
{
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "description": "Server recorded text based transaction confirmation",
    "secureTransactionContentType": "image/png",
    "secureTransactionContent": "aaaa...",                // base64 of the image
    "type": "FI"
}
                        </code></pre></p>
                                    <p><strong>Response</strong></p>
                                    <p><pre><code class="json">
{
    "href": "https://tenant.domain.com/IdentityXServices/rest/v1/authenticationRequests/authReq1",
    "id": "authReq1",
    "application": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/applications/app1"
    },
    "policy": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/policies/authPolicy1"
    },
    "user": {
        "href": "https://tenant.domain.com/IdentityXServices/rest/v1/users/user1"
    },
    "description": "Server recorded step-up authentication transaction",
    "secureTransactionContentType": "image/png",
    "secureTransactionContent": "aaaa...",                // base64 of the image
    "type": "FI",
    "fidoAuthenticationRequest": "[{"header": {"upv": {"major": 1,"minor": 0},"op": "Auth"}]...",
    "fidoAuthenticationResponse": null,
    …
}
                        </code></pre></p>
                                    <p>With the Java SDK, this can be achieved with: </p>
                                    <p><pre><code class="java ">
public AuthenticationRequest createImageBasedTransactionConfirmation(User aUser, 
             String confirmationImaseAsBase64) {

  try {
    AuthenticationRequest request = new AuthenticationRequest();
    request.setPolicy(this.getAuthPolicy());
    request.setApplication(this.getApplication());
    request.setUser(aUser);
    request.setDescription("Test transaction");
    request.setSecureTransactionContentType("text/plain");
    request.setSecureTransactionContent(confirmationImaseAsBase64);
    request.setType("FI");
    AuthenticationRequestRepository authenticationRequestRepo =
            this.getTenantRepoFactory().getAuthenticationRequestRepo();
    request = authenticationRequestRepo.create(request);
    return request;
  } catch (IdxRestException ex) {
    String error = "An exception occurred while attempting to create an auth request.  Exception: " +
        ex.getMessage();
    logger.error(error, ex);
    throw new RuntimeException(error, ex);
  }
}
                        </code></pre></p>
                                </div>
                            </div>
                            <!-- TRANSACTION CONFIRMATION -->
                            <!-- SAMPLE APPLICATION -->
                            <a name="sampleApplication"></a>
                            <div class="row">
                                <div class="col-lg-12">
                                    <h1>9.  Sample Application</h1>
                                    <p>Daon has provided a sample Java Relying Party Server Application (RPSA) and sample Android Relying Party App (RPApp) demonstrating how to integrate IdentityX into an existing application and app in line with the architecture shown in Figure 1 - FIDO Solution with IdentityX.</p>
                                    <h2>9.1 Relying Party Server Application</h2>
                                    <p>The RPSA is a Java 1.8 application and is supplied as an Eclipse project where its dependencies are managed using Maven.</p>
                                    <h3>9.1.1   Prerequisites</h3>
                                    <h4>Java</h4>
                                    <p>The RPSA requires Java 1.8 or higher. Ensure that Java Development Kit (JDK) is installed as the code will be compiled as well as run.</p>
                                    <p>Set the <em>JAVA_HOME</em> system variable to point to the location of the JDK. For example on Windows:</p>
                                    <p><pre><code>set JAVA_HOME= C:\Java\jdk1.8.0_60</code></pre></p>
                                    <p>Since the RPSA does use some cryptographic functions, you will also be required to download and install the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 8. </p>
                                    <a name="maven"></a>
                                    <h4>Maven</h4>
                                    <p>The RPSA is built by Maven. Ensure that Maven version 3.3.3 or higher is installed and available on the machine.</p>
                                    <h4>GitHub</h4>
                                    <p>The RPSA is hosted on GitHub at the following URL: <a href="https://github.com/daoninc/fido-rp-server">https://github.com/daoninc/fido-rp-server</a>. Either clone the repo to your local machine or download the ZIP file.</p>
                                    <h3>9.1.2   Editing the properties files</h3>
                                    <p>Once the prerequisites have been installed and the RPSA cloned/downloaded, it will need to be configured to work with the current environment and the available IdentityX instance.</p>
                                    <p>To set the details of your particular configuration, edit the following file:</p>
                                    <p><pre><code>src/main/resources/fido_config.properties</code></pre></p>
                                    <p>Change the following properties:</p>
                                    <ul>
                                        <li><em>fido.application_id</em>=the applicationId of application as created in the section Creating an Application in IdentityX</li>
                                        <li><em>fido.reg_policy_id</em>=the name of the registration policy as created in the section Creating the Registration Policy</li>
                                        <li><em>fido.auth_policy_id</em>=the name of the Authentication Policy as created in the section Creating the Authentication Policy</li>
                                        <li><em>fido.keystore.location</em>=the location of the key store containing the wrapping key. The file will be loaded from the class path if no explicit path is provided</li>
                                        <li><em>fido.keystore.password</em>=the password to the key store</li>
                                        <li><em>fido.keystore.keyAlias</em>=the name of the wrapping key within the key store</li>
                                        <li><em>fido.keystore.keyPassword</em>=the password to the key within the key store</li>
                                        <li><em>fido.credential.properties.location</em>=the name and location of the credential.properties file returned by the Admin Console when the token is created. The file will be loaded from the class path if no explicit path is provided.</li>
                                    </ul>
                                    <p>If the <em>keystore</em> and <em>credential.properties</em> file are to be loaded from the JAVA Classpath then they should be placed in the <em>src/main/resources/</em> directory.</p>
                                    <h3>9.1.3   Configuring Logging</h3>
                                    <p>Logging of the RPSA is directed through <a href="http://logback.qos.ch/">Logback</a>. The configuration file (<em>logback.xml</em>) is located in the <em>src/main/resources</em> directory. The output is directed to the log file <em>Relying_Party.log</em>. To change the location of the logging, the level of logging or to make other changes, the <em>logback.xml</em> file may be edited. Remember that this file will be packaged inside the built JAR, so if any changes are made, the JAR will need to be rebuilt.</p>
                                    <h3>9.1.4   Building and Running the Application</h3>
                                    <p>To run the application, install <a href="https://maven.apache.org/">Maven </a>, set the <em>JAVA_HOME</em>, and from the command line type:</p>
                                    <p><pre><code>mvn install spring-boot:run</code></pre></p>
                                    <p>This will compile, package, and run the application. The package process will create a single JAR file which will contain all the compiled classes, the dependent JARs, and the properties files. </p>
                                    <p>Unless otherwise configured, the application will run on port <em>8080</em> without TLS. To run on a different port, change the <em>server.port</em> setting in the file <em>src/main/resources/application.properties</em>.</p>
                                    <h3>9.1.5   Configure to run with TLS</h3>
                                    <p>To run the RPSA under TLS:</p>
                                    <ol>
                                        <li>An appropriate public / private key pair must be generated along with a Certificate Signing Request (CSR). The resulting CSR should be signed by a certificate authority whose root certificate is trusted by the device(s). The certificate should be imported to the key store where it can be accessed by the RPSA. For details on how to perform these operations with the Java Keytool, see: <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html">http://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html</a></p>
                        </li>
                        <li>Once the keys have been generated and the certificate imported, edit the <em>application.properties</em> file, uncomment the properties detailed below and set the values as follows:
                            <p><pre><code>
server.port: 443
server.ssl.key-store: {location of the keystore.jks}
server.ssl.key-store-password: {password to keystore}
server.ssl.keyStoreType: JKS
server.ssl.keyAlias: {aliasOfThePublicKey}
                            </code></pre></p>
                            <p>For further details on running with TLS, see the documentation on Spring Boot at: <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/">http://docs.spring.io/spring-boot/docs/current/reference/html/</a>
                                <p>
                        </li>
                        <li>Restart the application. </li>
                        </ol>
                        <h2>9.2 Relying Party App</h2>
                        <p>The Relying Party App is an Android application and is supplied as an Android Studio project and its dependencies are managed using Gradle.</p>
                        <p>The relying party app can be found at GitHub at the following URL: <a href="https://github.com/daoninc/fido-android-rp-app">https://github.com/daoninc/fido-android-rp-app</a></p>
                        <p>Clone the repo to your local machine.</p>
                        <p>To build the app, import the app into Android Studio.</p>
                        <h3>9.2.1   Updating Facets</h3>
                        <p>A core security feature of FIDO UAF is the ability to limit access to the authenticator key for an application. The Android app calling the FIDO client must be signed with a private key where the hash of the corresponding certificate must be in the Facets of the application represented by the Android app.</p>
                        <p>In practice that means when running under Android studio, the hash of the debug certificate must be included in the Facets of the Application. To generate the facet for the Android Studio debug certificate, a simple program has been included with the Android Relying Party Sample App. To generate the facet, run the class:</p>
                        <p><pre><code>com.daon.identityx.utils.GenerateAndroidFacets</code></pre></p>
                        <p>This must be run on the machine on which Android Studio is being used to run the Sample Relying Party App. The output of the program will be as follows:</p>
                        <p><pre><code>
Found the Android Studio keystore at: C:\Users\tsmith/.android/debug.keystore
Keystore loaded – password and location were OK
Certificate found in the store with name: androiddebugkey
Hashing algorithm: SHA1 found.
Base64 encoded SHA-1 hash of the certificate: dS6oorhfXCyrmiVFrh3lRr4HYKg=
Add the following facet to the Facets file in order for the debug app to be trusted by the FIDO client
"android:apk-key-hash:dS6oorhfXCyrmiVFrh3lRr4HYKg"
                        </code></pre></p>
                        <p>The last line (is the one that needs to be copied to the Facets file and/or to the Facets of the application set up in the <a href="#creatingAnApplication">Section: 2.2 Creating an Application in IdentityX</a>.</p>
                        <p>There are a number of system properties which can be supplied (using <em>“-D”</em> flag) when running the program on a different machine or outside of Android Studio:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 80%;">
                                <thead>
                                    <tr>
                                        <th style="width: 30%;">Property</th>
                                        <th style="width: 30%;">Description</th>
                                        <th style="width: 40%;">Default Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td id="href"><em>ANDROID_KEYSTORE_LOCATION</em></td>
                                        <td>Location of the Android keystore</td>
                                        <td><em>System.getProperty("user.home") + "/.android/debug.keystore"</em></td>
                                    </tr>
                                    <tr>
                                        <td id="href"><em>ANDROID_KEYSTORE_PASSWORD</em></td>
                                        <td>Password to the Android keystore</td>
                                        <td><em>android</em></td>
                                    </tr>
                                    <tr>
                                        <td id="href"><em>ANDROID_KEYSTORE_CERT_NAME</em></td>
                                        <td>Name of the signing certificate in the Android keystore</td>
                                        <td><em>androiddebugkey</em></td>
                                    </tr>
                                    <tr>
                                        <td id="href"><em>HASHING_ALGORITHM</em></td>
                                        <td>Algorithm to be used to hash the certificate</td>
                                        <td><em>SHA1</em></td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
						<p><strong>NOTE:</strong> If the facets are updated while the FIDO Relying Party Server Application is running, then the FIDO Relying Party Server Application must be restarted as the facets are cached by the Relying Party Server Application.</p>

                        <h3>9.2.2   Running the App</h3>
                        <p>The App can now be run from Android Studio and once started, the following screen should be displayed:</p>
                        <center>
                            <a href="#figure19" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_Intro_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 19: Sample RPApp – Intro Screen</figcaption>
                            </a>
                        </center>
                        <p>In order to connect to the Sample Relying Party Server Application, the details of the server must be provided. Click on the menu button and select <em>“SETTINGS”</em>. The following screen should appear: </p>
                        <center>
                            <a href="#figure20" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_Settings_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 20: Sample RPApp – Settings Screen</figcaption>
                            </a>
                        </center>
                        <p>Select <strong>URL</strong> and enter the IP Address or the DNS name of the server running the Sample Relying Party Server Application. Then select <strong>Port</strong> and enter the appropriate port. If the server is running under TLS, enable the <strong>“Secure Connection (https)”</strong> check box.</p>
                        <p>Return to the Intro screen.</p>
                        <p><strong>NOTE:</strong> If the device on which you are running does not have a FIDO client or has a FIDO client but does not have any authenticators then the <strong>“Login with FIDO”</strong> button will be disabled.</p>
                        <h3>9.2.3   Connecting from the RPApp to the RPSA</h3>
                        <p>If the RPSA is running on a locally addressable machine and the RPApp is running on a local device, both the RPSA and the RPApp need to be on the same network to connect. An alternative strategy is to use the Remote Debugging Tools provided in Google Chrome which will allow requests from the Android device to be proxied through the USB port to an attached workstation. See the following Google documentation for more details: <a href="https://developer.chrome.com/devtools/docs/remote-debugging">https://developer.chrome.com/devtools/docs/remote-debugging</a></p>
                        <h3>9.2.4   Creating a New Account</h3>
                        <p>To create a new user, touch the <strong>“New Account”</strong> button. The following screen will appear:</p>
                        <center>
                            <a href="#figure21" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_Sign_Up_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 21: Sample RPApp – Sign Up Screen</figcaption>
                            </a>
                        </center>
                        <p><strong>NOTE:</strong> The <strong>“Register with FIDO”</strong> check box will only be available if there is at least one FIDO client on the device and there are FIDO authenticators available.</p>
                        <p>Enter values for all fields and then when finished touch <strong>“Create”</strong>. Some basic validation is done on the device and errors will be presented if there is an issue.</p>
                        <p>If all the on-device validation checks are passed, a <em>CreateAccount</em> request is sent to the server. The server will validate the input and create an Account with the email address as the unique identifier.</p>
                        <p>Once the <em>Account</em> is created, if the request requests a FIDO registration, then a request is made to IdentityX to create a <em>User</em> there representing the <em>Account</em> in the Relying Party Server Application. That <em>User</em> is registered to the <em>Application</em> and a <em>RegistrationChallenge</em> is created for the User based on the FIDO Registration Policy (specified in the <em>fido_config.properties</em>). The RPSA will then return a <em>fidoRegistrationChallenge</em> to the RPApp which will invoke the FIDO client.</p>
                        <p>Assuming there is a suitable authenticator on the device to support the registration request, a screen similar to Figure 22 - Authentication Screen from Samsung S6 is shown to the user.</p>
                        <center>
                            <a href="#figure22" class="openModal">
                                <img id="imageresource" src="images/Authentication_Screen_from_Samsung_S6.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 22: Authentication Screen from Samsung S6</figcaption>
                            </a>
                        </center>
                        <p>Once the user’s fingerprint is verified, a FIDO registration response is returned to the RPApp which calls the RPSA with the <em>fidoRegistrationResponse</em> and the identifier of the <em>RegistrationChallenge</em> (this is the <em>CreateAuthenticator</em> request). </p>
                        <p><strong>NOTE:</strong> The call to the RPApp with the FIDO registration response must contain a header with the <em>Session-Id</em> passed back in the <em>CreateAccount</em> call. This method verifies that only an authorized caller may add a registration to the account.</p>
                        <p>The RPSA calls IdentityX updating the original <em>RegistrationChallenge</em> with the <em>fidoRegistrationResponse</em>. Assuming a successful outcome, the IdentityX server responds with a <em>fidoRegistrationConfirmation</em>, a <em>fidoResponseCode</em> and a <em>fidoResponseMessage</em>. These are relayed from the RPSA to the RPApp which calls the FIDO client. This closes the loop in the registration process and “commits” the registration with the FIDO client and authenticator.</p>
                        <p>Once all this is complete an <em>Account</em> has been created for the user and a FIDO Authenticator may be registered for the user. The user’s screen should switch to the Home screen as shown below.</p>
                        <center>
                            <a href="#figure23" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_Home_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 23: Sample RPApp – Home Screen</figcaption>
                            </a>
                        </center>
                        <p>To see the FIDO Authenticator, the administrator may logon to the IdentityX Admin Console and search for the user. The screen shown in Figure 24 - Authentication Requests in the Admin Console shows a list of authentication requests for a user.</p>
                        <center>
                            <a href="#figure24" class="openModal">
                                <img id="imageresource" src="images/large/Authentication_Requests_in_the_Admin_Console.png" style="width: 70%;border:1px solid black">
                                <br />
                                <figcaption>Figure 24: Authentication Requests in the Admin Console (click to enlarge)</figcaption>
                            </a>
                        </center>
                        <h3>9.2.5   Authenticators</h3>
                        <p>From the <strong>Home</strong> screen touch the <strong>“Authenticators”</strong> button and the following screen will appear with the details of registered authenticators for that account. The list will show all active and inactive authenticators.</p>
                        <center>
                            <a href="#figure25" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_Authenticators_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 25: Sample RP App – Authenticators Screen</figcaption>
                            </a>
                        </center>
                        <p>From this screen it is possible to register a new authenticator or deregister an existing authenticator.</p>
                        <h4>Registering a new Authenticator</h4>
                        <p>To register a new authenticator, touch the <strong>“Register”</strong> button. The RPApp will send a <em>CreateRegRequest</em> to the RPSA . The RPSA will validate the <em>session</em> and retrieve the <em>Account</em> details associated with the Session from the database. It will then determine if there is a <em>User</em> in IdentityX associated with the <em>Account</em>. If there is not, a new <em>User</em> and <em>Registration</em> will be created. Once the <em>User</em> and <em>Registration</em> are in place, a new <em>RegistrationChallenge</em> will be created in IdentityX with the FIDO registration policy indicated by the RPSA . The <em>href</em> of the <em>RegistrationChallenge</em> and the <em>fidoRegistrationRequest</em> will be returned to the RPSA and from there to the RPApp. The RPApp will in turn invoke the FIDO client with the <em>fidoRegistrationRequest</em>.</p>
                        <p>Assuming there is a suitable authenticator on the device to support the registration request, a screen similar to that shown in Figure 26 (the Registration screen shown on a Samsung Galaxy S6) is shown to the user:</p>
                        <center>
                            <a href="#figure26" class="openModal">
                                <img id="imageresource" src="images/Sample_Galaxy_S6_Registration_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 26: Samsung Galaxy S6 Registration screen</figcaption>
                            </a>
                        </center>
                        <p>Once the user’s identity is verified, a <em>fidoRegistrationResponse</em> is returned to the RPApp which calls the RPSA with the <em>fidoRegistrationResponse</em> and the <em>href</em> of the <em>RegistrationChallenge</em> in a <em>CreateAuthenticator</em> request. </p>
                        <p>The RPSA calls IdentityX updating the original <em>RegistrationChallenge</em> with the <em>fidoRegistrationResponse</em>. Assuming a successful outcome, the IdentityX server responds with a <em>fidoRegistrationConfirmation</em>, a <em>fidoResponseCode</em> and a <em>fidoResponseMessage</em>. These are relayed from the RPSA to the RPApp which calls the FIDO client. This closes the loop in the registration process and “commits” the registration with the FIDO client.</p>
                        <p>Once complete, the RPApp will request the updated list of authenticators from the RPSA and the user’s list of authenticators is refreshed.</p>
                        <h4>Deregistering an Authenticator</h4>
                        <p>To deregister an authenticator, an authenticator must be selected from the list of authenticators. If there are no authenticators then there are no authenticators to deregister. </p>
                        <p>There are four potential scenarios to examine in the context of deregistration based on two criteria:</p>
                        <ul>
                            <li>The state of the authenticator on the server (Server Auth State)</li>
                            <li>The presence of the authenticator on the device (Device Auth)</li>
                        </ul>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 80%;">
                                <thead>
                                    <tr>
                                        <th style="width: 20%;">
                                            <center>Server Auth State</center>
                                        </th>
                                        <th style="width: 10%;">
                                            <center>Device Auth</center>
                                        </th>
                                        <th style="width: 35%;">
                                            <center>Action</center>
                                        </th>
                                        <th style="width: 35%;">
                                            <center>Outcome</center>
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><em>Active / Blocked</em></td>
                                        <td>Yes</td>
                                        <td>A deregistration request is sent to the server and the resulting <em>fidoDeregistrationRequest</em> is sent to the FIDO client.</td>
                                        <td>Server makes the authenticator inactive. Device – there are two possible outcomes:
                                            <ol>
                                                <li>The authenticator on the device has the associated registration in which case it is removed. </li>
                                                <li>The authenticator on the device does not have the associated registration in which case the registration is not removed from the authenticator.</li>
                                                <ol>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><em>Active / Blocked</em></td>
                                        <td>No</td>
                                        <td>A deregistration request is sent to the server.</td>
                                        <td>Server makes the authenticator inactive. The registration is not removed from the authenticator meaning the user may have another device with an authenticator which contains an ARCHIVED registration.</td>
                                    </tr>
                                    <tr>
                                        <td><em>Archived</em></td>
                                        <td>Yes</td>
                                        <td>The <em>fidoDeregistrationRequest</em> is retrieved from the server.</td>
                                        <td>The authenticator remains archived on the server. Device – there are two possible outcomes:
                                            <ol>
                                                <li>The authenticator on the device has the associated registration in which case it is removed.</li>
                                                <li>The authenticator on the device does not have the associated registration in which case the registration is not removed from the authenticator.</li>
                                            </ol>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><em>Archived</em></td>
                                        <td>No</td>
                                        <td>No action is taken.</td>
                                        <td></td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p>While it may seem counter intuitive, the UI allows the user to deregister an ARCHIVED authenticator. This is to account for the situation where there is an authenticator on the device with a registration for the application but its registration is no longer valid (ARCHIVED) on the server.</p>
                        <p><strong>NOTE:</strong> The <strong>“Deregister”</strong> button will be disabled when:</p>
                        <ol>
                            <li>No authenticator is selected in the list, or</li>
                            <li>An authenticator is selected in the list, the authenticator is ARCHIVED and no authenticator or that type exists on the device </li>
                        </ol>
                        <h3>9.2.6   Logout</h3>
                        <p>Touching the <strong>“Logout”</strong> button sends a <strong>“DeleteSession”</strong> request to the server which deletes the associated <em>Session</em> from the RPSA database. Once the response is received from the server, the RPApp’s activity finishes and the user is returned to the <strong>Home</strong> screen.</p>
                        <h3>9.2.7   Delete Account</h3>
                        <p>Touching the <strong>“Delete Account”</strong> button requests the user to confirm the deletion of the <em>Account</em>. Once confirmed the RPApp sends a <strong>“DeleteAccount”</strong> request to the server. The process of deleting the <em>Account</em> is as follows:</p>
                        <ol>
                            <li>Deactivate all active FIDO Authenticators – the purpose of this step is to ensure there are <em>fidoDeregistrationRequests</em> available which can be passed to all FIDO authenticators associated with this user in an attempt to clean up registrations on the authenticators of the user.</li>
                            <li>Archive the user – the <em>User</em> within IdentityX is archived.</li>
                            <li>Delete the account – the <em>Account</em> within the RPSA is deleted.</li>
                            <li>Return <em>fidoDeregistrationRequests</em> – an array of ARCHIVED FIDO authenticator AAID with associated <em>fidoDeregistrationRequests</em> is returned to the RPApp.</li>
                        </ol>
                        <p>On the device, the FIDO Client is called with each of the <em>fidoDeregistrationRequests</em> for matching Authenticators on the device in an attempt to remove registrations.</p>
                        <p>Once the attempt is remove all the authenticators is complete, the RPApp’s activity finishes and the user is returned to the <strong>Home</strong> screen.</p>
                        <h3>9.2.8   Transactions</h3>
                        <p>The FIDO Alliance specifications allow users to view messages from the server and confirm those messages during the authentication process. IdentityX supports authentication transactions but FIDO Authenticators are not required to support transaction confirmation.</p>
                        <p>From the <strong>“Home”</strong> screen, touch <strong>“Transactions”</strong>. The Sample RP App - Transactions Screen will be shown:</p>
                        <center>
                            <a href="#figure27" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_Transactions_Screen.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 27: Sample RP App – Transactions Screen</figcaption>
                            </a>
                        </center>
                        <p><a href="#transactionConfirmation">Section 8</a> describes the four different types of authentications which are supported in the FIDO UAF Specifications. The screen allows the user to test each of these authentication types.</p>
                        <p>Each authentication request from this screen will result in a <em>CreateTransactionAuthRequest</em> being sent to the RPSA . In the RPSA the details of the authentication request are taken and an <em>AuthenticationRequest</em> is created in IdentityX. The only differences between the different authentications (open, step-up, text confirmation and image confirmation) are the attributes set on the <em>AuthenticationRequest</em> object sent to IdentityX.</p>
                        <h4>Open Authentication</h4>
                        <p>Screen Settings:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 50%;">
                                <tbody>
                                    <tr>
                                        <td>Step up Authentication Check Box selected</td>
                                        <td>No</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Confirmation Check Box selected</td>
                                        <td>No</td>
                                    </tr>
                                    <tr>
                                        <td>Image or Text</td>
                                        <td>N/A</td>
                                    </tr>
                                    <tr>
                                        <td>Text Field</td>
                                        <td>N/A</td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>Response:</strong> With these settings an open authentication request is sent to the server. If there is more than one persona registered for this AppID in the authenticator, the user will be requested to select the correct persona.</p>
                        <p><strong>NOTE:</strong> It would be unusual to make an open authentication request when the user has already been authenticated (has a session) but this example is provided for completeness. It would be more usual for a step-up authentication to occur in the context of the user already having been authenticated (having a session).</p>
                        <h4>Step-up Authentication</h4>
                        <p>Screen Settings:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 50%;">
                                <tbody>
                                    <tr>
                                        <td>Step up Authentication Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Confirmation Check Box selected</td>
                                        <td>No</td>
                                    </tr>
                                    <tr>
                                        <td>Image or Text</td>
                                        <td>N/A</td>
                                    </tr>
                                    <tr>
                                        <td>Text Field</td>
                                        <td>N/A</td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>Response:</strong> With these settings a step-up authentication request is sent to the server. The authenticators should not ask for the user’s persona as the authentication request is created for the specific user.</p>
                        <h4>Open Transaction Confirmation – Text</h4>
                        <p>Screen Settings:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 50%;">
                                <tbody>
                                    <tr>
                                        <td>Step up Authentication Check Box selected</td>
                                        <td>No</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Confirmation Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Image or Text</td>
                                        <td>Text</td>
                                    </tr>
                                    <tr>
                                        <td>Text Field</td>
                                        <td>Sample</td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>Response:</strong> With these settings, if the device has an authenticator which supports text based transaction confirmation, then the message is displayed to the user during the authentication process. If there is more than one persona in the authenticator registered for this AppID, the user will be requested to select the correct persona.</p>
                        <p><strong>NOTE:</strong> It would be unusual to make an open text transaction confirmation request when the user has already been authenticated (has a session) but this example is provided for completeness. It would be more usual for a step-up text transaction confirmation to occur in the context of the user having been authenticated already (having a session).</p>
                        <h4>Step-up Transaction Confirmation – Text</h4>
                        <p>Screen Settings:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 50%;">
                                <tbody>
                                    <tr>
                                        <td>Step up Authentication Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Confirmation Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Image or Text</td>
                                        <td>Text</td>
                                    </tr>
                                    <tr>
                                        <td>Text Field</td>
                                        <td>Sample</td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>Response:</strong> With these settings, if the device has an authenticator which supports text based transaction confirmation, then the message is displayed to the user during the authentication process. The authenticators should not ask for the user’s persona as the authentication request is created for the specific user.</p>
                        <h4>Open Transaction Confirmation – Image</h4>
                        <p>Screen Settings:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 50%;">
                                <tbody>
                                    <tr>
                                        <td>Step up Authentication Check Box selected</td>
                                        <td>No</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Confirmation Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Image or Text</td>
                                        <td>Image</td>
                                    </tr>
                                    <tr>
                                        <td>Text Field</td>
                                        <td>N/A</td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>Response:</strong> With these settings, if the device has an authenticator which supports image based transaction confirmation, then the image is displayed to the user during the authentication process. If there is more than one persona in the authenticator registered for this AppID, the user will be requested to select the correct persona.</p>
                        <p><strong>NOTE:</strong> It would be unusual to make a general image transaction confirmation request when the user has already been authenticated (has a session) but this example is provided for completeness. It would be more usual for a step-up image transaction confirmation to occur in the context of the user having been authenticated already (having a session).</p>
                        <h4>Step-up Transaction Confirmation – Image</h4>
                        <p>Screen Settings:</p>
                        <center>
                            <table class="table table-striped table-bordered" style="width: 50%;">
                                <tbody>
                                    <tr>
                                        <td>Step up Authentication Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Confirmation Check Box selected</td>
                                        <td>Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Image or Text</td>
                                        <td>Image</td>
                                    </tr>
                                    <tr>
                                        <td>Text Field</td>
                                        <td>N/A</td>
                                    </tr>
                                </tbody>
                            </table>
                        </center>
                        <p><strong>Response:</strong> With these settings, if the device has an authenticator which supports image based transaction confirmation, then the image is displayed to the user during the authentication process. The authenticators should not ask for the user’s persona as the authentication request is created for the specific user.</p>
                        <center>
                            <a href="#figure28" class="openModal">
                                <img id="imageresource" src="images/Sample_RPApp_the_setting_for_Transaction_Confirmation.png" style="height: 50%;border:1px solid black">
                                <br />
                                <figcaption>Figure 28: Sample RP App – the setting for Transaction Confirmation</figcaption>
                            </a>
                        </center>
                        </div>
                        </div>
                        <!-- SAMPLE APPLICATION -->
                        <!-- COMMON ERRORS -->
                        <a name="commonErrors"></a>
                        <div class="row">
                            <div class="col-lg-12">
                                <h1>10. Common Errors</h1>
                                <h2>10.1    Illegal key size or default parameters Server</h2>
                                <p>One of the most common RPSA errors occurs when Java is installed but the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files have not been applied to the Java installation. This will generally result in exception such as the one below:</p>
                                <p><pre><code>Caused by: java.security.InvalidKeyException: Illegal key size or default parameters</code></pre></p>
                                <h3>Resolution</h3>
                                <p>Download and install the <a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files</a>.</p>
                                <h2>10.2    The Final Challenge Params were not successfully validated</h2>
                                <p>This error is typically caused when the Facet used by the FIDO Client (as reported in the Final Challenge Parameters) is not a Facet known to the IdentityX server</p>
                                <h3>Resolution</h3>
                                <p>Edit the Application in the IdentityX Admin Console and add the appropriate Facet to the list of facets. This is covered in the section on <a href="#creatingAnApplication">Creating an Application in IdentityX</a>.</p>
                                <h2>10.3    The FIDO Client reports that the App is not trusted</h2>
                                <p>There are a number of possible reasons for this error and they are generally related to the Facets JSON document.</p>
                                <h3>Resolution</h3>
                                <p>Ensure that the URL for the Facets document is at a TLS location (<em>https</em>) where the root certification is trusted by the device.</p>
                                <p>Ensure that the <strong>Content-Type</strong> of the Facets document is <strong>“application/fido.trusted-apps+json”</strong>. In testing, the Samsung Galaxy S6 accepts <strong>“application/json”</strong> as a valid <strong>Content-Type</strong>.</p>
                                <h2>10.4  Incorrect Maven Version</h2>
                                <p>The following error occurs during the build/run process.</p>
                                <pre><code>
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ------------------------------------------------------------------------
[INFO] Error configuring: org.springframework.boot:spring-boot-maven-plugin. Reason: Unable to retrieve component configurator for plugin configuration
[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
                        </code></pre>
                                <h3>Resolution</h3>
                                <p>Check that the correct <a href="#maven">version</a> of Maven is installed. If the version of Maven is too old it may not support all the required build features.</p>
                                <h2>10.5  Cannot connect to the IdentityX Server</h2>
                                <p>The following error occurs during the build/run process </p>
                                <pre><code>
[WARNING]
java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.springframework.boot.maven.RunMojo$LaunchRunner.run(RunMojo.java:418)
        at java.lang.Thread.run(Thread.java:745)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'simpleController': Injection of autowired dependencies failed; nested exception is org.springframewor
k.beans.factory.BeanCreationException: Could not autowire field: private com.daon.identityx.fido.IIdentityXServices com.daon.identityx.controller.SimpleController.identityXServices; nested exception i
s org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'identityXServices': Invocation of init method failed; nested exception is java.lang.RuntimeException: An excep
tion occurred while attempting to connect to the IdentityX server.  Exception: Failed to initialize the Credential Provider
        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334)
        ... 6 more
Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.daon.identityx.fido.IIdentityXServices com.daon.identityx.controller.SimpleController.identity
XServices; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'identityXServices': Invocation of init method failed; nested exception is java.la
ng.RuntimeException: An exception occurred while attempting to connect to the IdentityX server.  Exception: Failed to initialize the Credential Provider
        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:561)
        ... 22 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'identityXServices': Invocation of init method failed; nested exception is java.lang.RuntimeException:
An exception occurred while attempting to connect to the IdentityX server.  Exception: Failed to initialize the Credential Provider
        at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:136)
        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:533)
        ... 24 more
Caused by: java.lang.RuntimeException: An exception occurred while attempting to connect to the IdentityX server.  Exception: Failed to initialize the Credential Provider
        at com.daon.identityx.fido.IdentityXServices.connectToIdentityXServer(IdentityXServices.java:124)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:349)
        at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:300)
        at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBefo...
                        </code></pre>
                                <h3>Resolution</h3>
                                <p>The relying party app cannot connect to IdentityX. The <em>credential.properties</em> is probably incorrect or not correct. <a href="#creatingAToken">Has a new token been created?</a></p>
                            </div>
                        </div>
                        <!-- COMMON ERRORS -->
                        <!-- OTHER FIDO SERVERS -->
                        <a name="otherFIDOServers"></a>
                        <div class="row">
                            <div class="col-lg-12">
                                <h1>11. Other FIDO Servers</h1>
                                <h2>11.1    FIDO Alliance UAF Specifications</h2>
                                <p>The <a href="https://fidoalliance.org/">FIDO Alliance</a> <a href="https://fidoalliance.org/specifications/overview/">UAF Specifications</a> define the format of the messages which go between the FIDO Client and the FIDO Server.  The specifications do not determine how these messages are sent to a FIDO Server by a Relying Party.  This is an important distinction as the FIDO Alliance did not want to create a “Server API” and thus impose technology constraints on the FIDO Server implementers thus allowing them to select the most appropriate communications protocols, security schemes etc. to meet their requirements.</p>
                                <h2>11.2    Other FIDO Server Implementations</h2>
                                <p>In this document, the IdentityX server interface is described.  This is Daon's proprietary interface to IdentityX.  To use the Relying Party Server Application with a different FIDO Server, the code of the RPSA will need to be updated to integrate with the interface to the new FIDO Server.</p>
							</div>
                        </div>
                    </div>
                    <center><strong>© 2015 Daon Holdings Limited. All rights reserved.</strong></center>
                </div>
            </div>
            <!-- /#page-content-wrapper -->
        </div>
        <!-- Simple Modal to display the images. -->
        <div class="modal fade modal-wide" id="imagemodal">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-body">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>
                        <center><img src="" id="imagepreview" style="max-width: 100%;"></center>
                    </div>
                </div>
            </div>
        </div>
        <!-- /#wrapper -->
        <!-- jQuery -->
        <script src="lib/jquery.js"></script>
        <!-- Bootstrap Core JavaScript -->
        <script src="lib/bootstrap.min.js"></script>
        <!-- Menu Toggle Script -->
        <script>
        $("#menu-toggle").click(function(e) {
            e.preventDefault();
            $("#wrapper").toggleClass("toggled");
        });
        </script>
        <script>
        $(".openModal").on("click", function(e) {
            e.preventDefault();
            $('#imagepreview').attr('src', $(this).find('img').attr('src'));
            $('#imagemodal').modal('show');
        });
        </script>
</body>

</html>
